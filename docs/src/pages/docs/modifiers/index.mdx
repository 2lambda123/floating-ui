---
title: Modifiers
---

# Modifiers

Popper is built using an extensible core, which provides the foundation used to
deliver all the functionalities offered by the library.

All the useful functionalities provided by the library are implemented as Popper
modifiers. They are plugins, or middlewares, that can hook into the lifecycle of
Popper, and add additional logic to the positioning operations provided by
default by Popper. They effectively "modify" the popper state in some fashion,
adding functionality, hence the term "modifiers".

## Custom Modifiers

Is it possible to add custom modifiers, written by you, by defining them in the
`options.modifiers` array during a Popper instantation.

```js
createPopper(reference, popper, {
  modifiers: [myCustomModifier],
});
```

A modifier is composed of an object with the following properties:

```js
{|
  name: string,
  enabled: boolean,
  phase: ModifierPhases,
  requires?: Array<string>,
  fn: ({ state, options, name, instance }: ModifierArguments<Options>) => State,
  onLoad?: State => void,
  onDestroy?: State => void,
  options?: any,
  data?: {},
|};

type ModifierArguments<Options: Obj> = {
  state: $Shape<State>,
  instance: Instance,
  options: $Shape<Options>,
  name: string,
};
```

### `name`

The name is used as an identifier to make it possible to refer to the modifier
from other parts of the library. For example, you can add an object to the
`options.modifier` array with the `name` property, and the `options` property
populated with some custom options, to override the options of a built-in
modifier.

```js
createPopper(reference, popper, {
  modifiers: [
    {
      name: 'flip',
      fallbackPlacements: ['top', 'bottom'],
    },
  ],
});
```

### `enabled`

If set to `true`, the modifier will be executed during the Popper lifecycle,
otherwise, it will be ignored.

### `phase`

Popper's modifiers lifecycle is divided into 3 core phases: `read`, `main`, and
`write`. This is done to optimize the library so that its access to the DOM is
grouped together rather than scattered around the whole lifecycle.

The modifiers that need to read from the DOM should run in the `read` phase, the
ones that only perform logic with algorithms should live in `main`, and the ones
that write to the DOM should be under `write`.

Note that Popper provides a cache of DOM measurements in its state, so that
modifiers can read them rather than querying the DOM, optimizing the overall
execution time. This means you should rarely need to hook into the `read` phase.

For further granularity if needed, there are 2 other sub-phases: `before` and
`after`. Here is the full list:

- `beforeRead`
- `read`
- `afterRead`
- `beforeMain`
- `main`
- `afterMain`
- `beforeWrite`
- `write`
- `afterWrite`

### `requires`

Each modifier can specify a list of modifiers it depends upon, so that Popper
will execute them in the right order to allow the dependent modifier to access
the data provided by the dependee modifier.

An error is thrown if the modifier is not passed, so this data will be
guaranteed to be available via `state.modifiersData.<MODIFIER_NAME>`.

### `optionallyRequires`

Each modifier can specify a list of modifiers it **optionally** depends upon.
That is, it only depends upon it if the modifier is actually present and running
modifications to the state. If it doesn't exist in `modifiers`, it will get
ignored.

For example, the `preventOverflow` modifier optionally relies on
`offset`-provided data, which is accessed from `state.modifiersData.offset`. If
`offset` doesn't exist, `preventOverflow` will still work as normal.

### `fn`

This is the main function, used to provide the logic to the modifier.

The signature is straightforward, it provides the Popper state, and the modifier
options, and must return the (optionally altered) `state`.

There are cases when you may want to control the Popper lifecycle through a
modifier, for example, the `flip` modifier can alter the `placement` option, and
if that happens, Popper is instructed to run all the modifiers again, so that
they can react to the updated placement value.

A modifier can reset the lifecycle by setting `state.reset` to `true`.

### `onLoad`

This function is executed when the Popper instance is created, it can be useful
if you need to execute one-time operations on Popper instantation.

### `onDestroy`

Just like `onLoad`, but runs when the Popper instance is destroyed.

### `options`

This is usually an object with all the properties used to configure the
modifier.

### `data`

If you desire to share data generated by your modifier with other modifiers, you
can populate this object with some defaults, and update it inside your modifier
by altering `state.modifiersData.<MODIFIER_NAME>`.
